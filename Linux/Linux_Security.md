
---
 1- intro, memory vulenrability, dnf update, gpg, luks 2- openssl, FireWall, iptables, Nmap, firewallD 3- SELinux - SSH Hardening 4- ssh hardening 6- t’atil shod 7- audit - dns security - OpenScap 8- OpenVAS, Securing user accounts, PAM, Suricata 9- IPSEC, USBGuard, Reset Root Password & hardening GRUB2, Securing cronjob, FreeIPA 
---
 **Concepts: ** - NDA: قرارداد عدم افشا - IOA (Indicator Of Attack): flow of attack, it’s a pattern. - IOC (Indicator Of Compromise): addresses of servers that malware send traffic to them. - Botnet/zombie : an infected system that is going to be used in dos attack - CDN see all of data decrypted, and can capture data. - NOC (مرکز) - SOC (مرکز) - CERT (مرکز) : computer emergency responce team - Threat : رفتار خطر دار - vulnerability: آسیب پذیری - exploit : بهره‌برداری از آسیب‌پذیری - payload: شیوه مانیتور کردن از یک اکسپلویت - post exploitation : بهره‌برداری در‌ آینده - back door: دسترسی برای آینده - auxiliary : tools for scanning, sniffing, fuzzing - Anonymous: هویت ناشناس، ولی کارها شناسایی پذیر. یعنی وقتی عملکردت ردیابی شد، نتونن بفهمن کی پشت قضیه بوده. در اینترنت مهاجمین دنبال این هستند. به عنوان یک پالیسی در نظر گرفته می‌شود - footprint: ردپای عمل انجام شده. هنر حمله کننده، پاک کردن رد پاست - fingerprint: hash برای ساده‌شدن کار ایجاد شده است - weakest chain : security of a chain is as much of it’s weakest part - Core dump : if something went wrong and system/app/process crashes, if the ability is enabled, then it is going to take a dump (snapshot) of memory. you can use GDB (a debugger) to later on troubleshoot, it is systemd’s responsibility to do so. core dumps are bieng saved in directory of /var/lib/systemd/coredump - Tactic: Denial Of Service - Technique: how to operate tactic, SYN flood ——————————————— **Commands:** - [TAB] [TAB] —> see recommendations - $strace —> sys call trace, $ltrace —> library call trace, $ptrace —> process trace for debugging and injection - $strace -p 1 —> what syscalls pid 1 is using - $ldd /usr/bin/ls —> see what libs a software is using - $ users —> online users logged in system, right now - $ file a.txt —> show info about a.txt - $ ln —> hard linking - $ lsmod —> list all modules that are running on kernel - $ & (flag) —> in background - $ nc -nlvp [port number] —> open port - $ netstat -antp —> show all open ports - $ systemctl list-units —type slice —> show users unit in systemd - $ dd if=/dev/zero of=/dev/null bs=1M & —> fake cpu usage for benchmarking - $ cron -e —> do something on schedule that i am telling you - $ namectl set-hostname ASGHAR, $ bash —> change name and re-open terminal - $ jobs -l —> list all jobs on the system; active, stopped, or otherwise - $ kill -9 [PID] - $ cp -p /home/john/fosh.txt —> don’t change any attributes and timestamp of file when copied - $ grep -i pwquality \* —> search for pwquality in all files of this directory packages: - $dnf update —> update repos - $ dnf update -security —> just update security related packages - $ dnf updateinfo —> showing info about packages with they’re updates. - $ dnf updateinfo list updates security —> showing info about packages with they’re updates. - because of recent filtering situation and better performance of package manageres - 1- $ vim /etc/dnf/dnf.conf - skip_if_unavailabel=True - fastestmirrod=1 - 2- $ dnf update libmodule —> when encountered yaml file missing warnings ——————————————— **Tips and Tricks:** - keyring is a kernel component, it caches encrypted keys which are kernel level on user space - for deleting important data : shred -u -z -n 9 -v secret.txt - why a encoded file is openable with less, but not with cat? because less save file in memory then read it, and therefore can access keyring. - PEM Format: —— begin pub key ——— base64 encoded pub key —— end pub key ——— - key pairs should be generated on a desktop system with gui and personal data, because it has more entropy - do $ echo $? after EVERYTHING! - Some free firewalls: pfsense - open sense - firepower - Check out these NSM (Network Security Monitor): zeek - bro - Dirbuster for crawling all directories in a web server - cockpit is a service that auromate and make monitoring of all systemD services easier - executable file format on windows is PE, on linux is ELF(executable and linkable and libraries format) - IMPORTANT: bash scripts (and all interpreter scripts and files / not compiler-based) have to had read permission in order to execute. Elf formats are ok if there is no read permission in order to execute - After you set users up, do this so there could not be changes and hackers can’t add users. Mostly one of first actions a hacker does is creating a user for himself, Users are mostly created by names like mysqld —> chattr +i /etc/passwd - BLP (bella padolla) is a security model - after installing SELinux on Debian based systems, after first reboot it took 30-40 mins to label resources - Hardening should happen, then after that a system/machine go for production. Otherwise there could be rootkits that you’ll never know of. - Kernel is RO(read only) when system is starting up, why? because if there is a malware, it could be loaded on ram along kernel, which is extremely dangerous. - for setting line numbers in vim —> :set nu - for grepping binary files use -a (asci) switch - for converting epoch time using terminal —> $ date -d @1671122464 - Hardening should be implemented using threat modeling, not best practices! You must create models and analyze environment and do risk assessment before hardening. - If you are tunneling, you should check for dns leakage (there are even some online sites). it means that you have tunnel, but dns requests are being sent outside of that - one of ways an anti virus is working is by hashing a file and checking the hash value with its database. one of ways for by passing this is binary padding, it add one bit/byte to file, it could be nops (no operation file, which does nothing) so the hash value would be changed - for searching in vim use / - in encryption algorithms : aes256-ctr —> (counter) stream-based bit by bit, aes256-cbc —> cipher block chaining, etc. - when there is a bash given to a user, all of .sh data inside /etc/profile.d is being read - for forcing a bash script to re-execute (without restart) you can $ source a.sh - search engines that hackers use : shodan, censys, binaryage - search what is shadowserver - POSIX : a UNIX-based standard that is introduced by Richard Stallman to have standardization over all distributions. - Threads don’t have access to their parent’s heap and stack - attack on apache : since its thread based, then tools such as slowhttptest (developed by google) causes exploitation, this tool creates threads then start sending data very slowly - to find syscall using its number : 1- searching in $ vim /usr/include/asm/unistd_64.h 2- $ ausyscall —dump - install mitre attack navigator on docker - for systems with very low ram and cpu, use haveged package to create public-private keys - what is salt in passwords and /etc/shadow? it is a phrase that is being used to if a password was being hashed twice, none of them are looking alike. - files in directory inheritance access from their parent directory. so if a file is in john’s home directory which had 700 permission and root:root owner, john can force it to change because directory is his. - if you have written a script, copy it in this directory since there is no inheritance going on (nokte balayi) /usr/local/sbin/ - avml tool is for data dumping RAM - keyring is a place in kernel where all sessions are being cached. in system if you’ve entered password in last 5 mins then there is no need to enter password again. can be flushed using sudo -k - .so —> shared object - after restarting a service, see its status ——————————————— **Interview Questions:** - What to do in heavy DDOS attacks? Tell Internet Service Provider - What mask does in systemd? Link a service to /dev/null, so another service can’t start it. Should be done after $ systemd stop service - What kernel process is being called when memory is full? OOM (out of memory clear process) - What is dot (.) you see in end of files (only red hat distros) after $ ls -l —> -rw———. ? it is linking to acl.c file, you can define access control on it, it is one of SELinux features, dot (.) show that access control is not set on this file and plus (+) show that access control has been set. - Is it possible that on a system, two files have same inode? Yes, in case they are both hard linked - Is it possible that on a system, two seperate files have same inode? Yes, in case they are different partitions - Why a hacker after attack wants to have a reverse shell on system to his system? To have Permanent access - for bypassing firewalls, mostly firewalls of corporates are not good for output traffic, no one actually cares what traffic is going out - what is difference between service reload / service restart in systemd? in reload HangUp signal will be sent, so config file will be read again but the pid won’t be changed - what is #!bin/bash ? it show who is interpreter of this file - Is it possible to have 2 UID=0 (root) in a system? yes, attackers would create a user and change its UID & GID in /etc/passwd to 0:0, in lots of situations this number is being checked so attacker has root level access to lots of things. How to check it? $ awk -F ‘($3 == “0”) {print}’ /etc/passwd - what is forkbomb :(){ :|: & };: ? a function name : is defined, it is going to : to itself and go to background and then call it. infinite loop - What is DRDOS (Distributed Reflection Denial of Service attack)? first thing to know is UDP has reflection attacks, this DRDOS means system is infected and being used for attacking somewhere else ——————————————— **Important dir:** - cat /proc/sys/kernel/random/entropy_avail —> to check entropy number of system - ls /dev/mapper/ —> show lvm and raid and luks mappings - /proc/net/xt_recent —> address of iptables’ workflow made by Conntrack module - /lib/systemd/system —> where all units are - /etc/login.defs —> some password related stuff, some are being override with PAM - /lib/systemd/system/suricata.service —> all services are here ——————————————— **Important syscall:** - EXECVE : when a binary is being executed, this sys call must be called. all commands that are being executed in terminal call this - ptrace : for debugging, binding malicsouse code to processes by attacker - memfd :binding malicsouse code to RAM by attacker, file less attack ——————————————— **kernel parameters:** - NX/XD : a cpu feature in linux, no execute/execute disable. disable user to enter cpu upcode instead of data inside ram. to check it: $dmseg | grep -i nx / or / cat /proc/cpuinfo | grep nx (1-2) - ASLR (KASLR is better): memory address is random, so hacker has more work to. should be 2\. its a kernel parameter. ——————————————— **MalWare:** - wanna cry: send stuff to it server - IP Spoofing: when attacker changes source ip of packet that it sent - smurf attack: attacker send packets to all of network and set the source ip to victim’s IP, all of network want to reply that packet, DDOS attack - UDP Fragmentation ——————————————— **Bash Script for automation:** - $ awk -F ‘($3 == “0”) {print}’ /etc/passwd —> check if attackers would create a user and change its UID & GID in /etc/passwd to 0:0, in lots of situations this number is being checked so attacker has root level access to lots of things. 
---
 **Classes** 
---
 [1- intro, memory vulenrability, dnf update, gpg, luks] - integrity, availability, confidentiality - what is CVE: common vularanbility and exposures. شناسه - cvss3 score: update more than 7.5\. in [first.org](http://first.org) —> مرجع رسیدگی به رخدادهای امنیتی جهانی. there is a calculator. - ۹۰ درصد مشکلات سیستم عامل به خاطر مدیریت حافظه، بافر اورفلو، استک اورفلو و این‌هاست. چون ۹۰ درصد سیستم عامل با c کد خورده است و c می‌تواند مدیریت معماری سطح پایین کند که می‌تواند مشکل آفرین باشد. - ساختار معماری هنگامی که نرم‌افزاری اجرا می‌شود: پایین کد، بعد متغیرهایی که در کد assign شده اند، بعد متغیرهای assign نشده، بعد هیپ که داینامیک مقداردهی می‌شود، بعد استک. استک به صورت خودکار خالی می‌شود ولی هیپ باید توسط دولوپر در برنامه خالی شود. - asgari machine: user —> root, pass —> qazwsx - $dhclient —> get ip after machine started up - $gunzip /etc/yum.repos.d/\* —> to enable update on asgari machine - fileless malware: straightly on ram. using memfd syscall - segmentation fault —> on ram, you are writing on a sector that you don’t have permission too write on. - core dump —> will dump all of ram when a crash happens - executable file format on windows is PE, on linux is ELF(executable and linkable and libraries format) - what is posix? a standard library for different distributations. - virtual dynamic share object —> kernel level, for optimizing performance of library **gpg:** - $ gpg —keyid-format LONG —list-keys —> for showing keyID - $ gpg —edit-key Ahmadi > trust —> for trusting a public key - $ gpg —send-keys —keyserver [keyserver.ubunto.com](http://keyserver.ubunto.com) [KeyID] —> send public keys to a key server - $ gpg —keyserver [keyserver.ubunto.com](http://keyserver.ubunto.com) —search-keys [ahmadi@ahmadi.ir](mailto:ahmadi@ahmadi.ir) —> send public keys to a key server - pub —> public primary key, sub —> public sub key, it is implemented for the day pub primary key is compromised and you want to revoke it. it is also being used for signing and for encrypting. - how to encrypt a test directory: - $ tar -cvf test.tar test/\* - $ gpg -c test.tar - how to decrypt a test encrypted directory: - $ gpg -d test.tar.gpg > test.tar - $ tar -xvf test.tar **luks**: - symmetric encription, kernel space, make hdd slots, then encrypt them, has about 1-3% overhead and less than 20s for first mount. when write a file in it, data isn’t encrypted, blocks of hdd is encrypted. because it has encrypt blocks when mounting, there is no overhead after that. luks interface keeps offsets of encrypted blocks. - first add hdd, then partition it ($ fdisk /dev/sdb), then $ cryptsetup luksFormat /dev/sdb1, passphrase must have complexity because it will fail at the end if it’s not complex enough, then $ cryptsetup luksOpen /dev/sdb1 secret (for mounting and mapping with name), now filesystem $ mkfs -t ext4 /dev/mapper/secret, make mount point in / dir $ mkdir /secret $ mount /dev/mapper/secret /secret/, now we want to make it somehow that there is no need to enter pass each time system boot $ dd if=/dev/urandom of=/root/key bs=1M count=1, $ ls -lh, $ chmod 600 key, $ ls -lh, now add this key to luks interface $ cryptsetup luksAddkey /dev/sdb1 /root/key, for making this changes permanent after reset $ vim /etc/crypttab, then write this column inside it : secret /dev/sdb1 /root/key defaults, now configure fstab $ vim /etc/fstab, and write this column inside it : /dev/mapper/secret /secret ext4 defaults 0 0, echo $?,$ reboot - for unmounting a luks hdd: $ umount /secret, then because hdd’s pass is cached another sudoer can easily see it should do $ cryptsetup luksClose /dev/mapper/secret - must have two keys set, one spare one primary. ——————————————— [2- openssl, FireWall, iptables, Nmap, firewallD] **openssl:** - what is difference between ssl & tls? ssl v1 was not released, ssl v2 was released in 1995 and worked till 2011, had drown attack, ssl v3 was in 2015, had poodle attack. then tls was used instead as a improved version, v1.0 1999-2020 had technichal and implimentation problems, v1.1, v1.2 2008-2020, v1.3 2018-now - Diffi Hellman is for symmetric key exchange in TLS triple handshake, It has nothing to do with encryption - There are different kind of ssl certificates. For example: DV cert —> Domain Validation (classic one), OV cert —> organization validation, EV cert —> both domain and organizartion, as a result in browser it shows [digital.com](http://digital.com) after ssl lock, wildcard cert —> \*.[a.com](http://a.com) - CSR: certificate signing request, what you send to CA - PKCS: set of cryptographic standards. - X.509: data structure of a certificate - CRL: certification revokation list - You can get pub key from a private key, but not vice versa. It is being done by modulus & exponent part of private key - Why set a password on CSR? To disable revocation by a bad/ex-employee - FIPS: a set of standards by US nist, which a software have to have in order to publish and being used - testssl.sh ابزار —> scan vulenarabilities on ssl/tls. Find on GitHub. $ ./testssl.sh [lms.anisa.co.ir](http://lms.anisa.co.ir) - Use let’s encrypt with 3 months timespan certificate, certbot is the tool for automation of it - $ openssl x509 -pubkey -noout -in cert.crt —> public key from certificate - $ openssl rsa -in private.key -pubout —> public key from private key - $ openssl s_client -connect [kernel11.com:443](http://kernel11.com:443) —> show text info of a cert on internet **iptables:** - In linux, firewall is netfilteer. In new OSs it is nftable. It is a kernel-level framework - Port scan (one of first actions a hacker do) - What does -j (jump) RETURN does? It is for returning from a newly created chain to another chain (for example INPUT/OUTPUT) - Use sniff for logging all of body and header of packets. - Extension modules: ( -m ) - Multiport - IPRange - Connlimit : for concurrent connections that are established. It is right now, not last 60 sec for example - State [NEW (establishing) - ESTABLISHED - RELATED (recursive establishing request) - INVALID (send inappropriate request, for example for establishing a connection send ack instead of syn)] - Conntrack : create flow of established connections and save it in ram (address of flow is /proc/net/xt_recent ). It uses a window time - Recent : actions based on conntrack flow - How to refuse SSH Brute Force (fail2ban has better performance): $ iptables -I INPUT -p tcp —sport ssh -m conntrack —ctstate NEW -m recent —set $ iptables -I INPUT -p tcp —sport ssh -m conntrack —ctstate NEW -m recent —update —second 60 —hitcount 10 -j DROP (each 60 sec update flow inside ram, if there were 10 new connections from a specific source, drop 11th and all of next requests) - How to refuse port scan: create a new chain and then write rules there, because if it’s in default chains, there’s gonna be overhead for each request that comes in. $ iptables -N PORTSCAN $ iptables -A PORTSCAN -p tcp —syn -m limit —limit 2000/hour -j RETURN $ iptables -A PORTSCAN -m limit —limit 1000/minute -j LOG —log-prefix “PORT SCAN DETECTED” $ iptables -A PORTSCAN -j DROP $ iptables -A INPUT -p tcp —syn -j PORTSCAN - $ iptables -I INPUT -p tcp -m state —state ESTABLISHED,RELATED -j ACCEPT - Use —number-line for numbering lines **FirewallD:** - what is format of services and zones of firewallD? xml - /usr/lib/firewalld/services —> permanent config and zones - /etc/firewalld —> runtime changes. override /usr/lib/firewalld/services when apply changes in runtime ——————————————— [3- SELinux, SSH Hardening] **SELinux**: - Make all of os to subject and objects, and then will check if a subject has access to object. which is a labeling/contexting tool. - DAC: is on all OSs, read write execute permissions, is not great for specified access controls. - MAC: upper then DAC. SELinux is in this level - LSM Framework is built-in in all of distributions, security implementations are in it. SELinux is in this level. AppArmor is another LSM which is built-in for ubuntu, Tomoyo is another one. - Tip: after configuring SELinux on a machine, it should work for a good amount of time for staging and testing purposes, then goes for production. In this testing time, SELinux must work on permissive mode and work with it 1 week - Extended regular DAC: - Acl is file-system level, it overrides permissions. - $ setfacl $ getfacl - What is dot (.) you see in end of files (only red hat distros) after $ ls -l —> -rw———. ? it is linking to acl.c file, you can define access control on it, it is one of SELinux features, dot (.) show that access control is not set on this file and plus (+) show that access control has been set. - What is mask in facl? It is maximum permission for a file. Implementation is on group. - $ setfacl -m u(User)|g(Group):username|groupname:Perm(rwx|7) file_name —> example: $ setfacl -m u:hacker:rwx a.txt - $ setfacl -x g:wheel a.txt —> delete wheel group access control - $ setfacl -b a.txt —> removes flag related to facl. (+) turns to (.) - EA (Extra Attribute) —> at first it was implemented for ext family file system. - $ Lsattr a.txt —> see attributes of a file, $ chattr a.txt —> change attributes of a file. - A (append) —> users and processes can only append to a file. $ chattr +a a.txt $ chattr -a a.txt will remove -a attribute. - I (immutable) —> all changes in file system level is discarded. modify move and remove are not allowed. - S (secure delet) - C (compress during writing on hdd) - SELinux is based on two main things: 1-context 2-Boolean - SELinux has three modes: disabled, permissive (just log), enforcing (is active). $ setenforce enforceing(1)|permissive(0) changes the mode, you can’t setenforce to disable, $ get enforce shows the mode - $ sestatus —> show status of selinux. - SELinuxfs mount —> mount file system on another part so that it is integerated with more security. It is common to do this, since FS is virtual. - SELinux root directory —> where the config files are. - Loaded policy name —> minimum, targeted (300-400 scopes, users, sockets, processes, services and apps have built-in profiles and monitoring is on them), MLS/MCS (Multi Level Security, Multi Category Security. it has multi level security for who can what access to which resource. it uses bella padolla model. tuning MLS takes lots of time.) - curent mode —> current run-time sestatus - Mode from config file —> config file is in $ vim /etc/selinux/config. for permanently making it disabled, should change this config file. there is another softlink to this file in $ vim /etc/sysconfig/selinux - Policy MLS status —> enabled means there are some profile for users, for really enabling it should install third party packages. - Policy deny_unknown status —> in case a process hasn’t profile, can I deny some of it requests / syscalls were not ok for me, can i deny it access? - Memory protection checking —> can SELinux protect Memory? (man mprotect 2) - Max kernel policy version —> version of SEELinux - SELinux context: User:Role:Type:Level - in targeted mode, every users are Unconfined, every roles are object_r, every levels are s0 - -Z switch is for contexts of SELinux. for example ls, ps, mkdir, cp, etc. $ ls -lZ - $ echo salam > /var/www/html/a.html, $ ls -lZ —> Type of file is httpd_sys_content, because it belongs to httpd domain and SELinux has contexted it rightly. this categorizing is efficient for security, only certain processes can access certain contexts - For mapping groups, should map to roles not users. - A SELinux User is defferent from a Linux user. Can view all 8 SELinux Users by $ seinfo —user : - root: root user - staff_u: sysadm_u but they can only $sudo and can’t use $su - sysadm_u: all administrator users - system_u: systematic users - unconfined_u: un-labeled users - user_u: unpriviledged users - guest_u: - xguest_u: have graphics and firefox - Scenario: Create a guest_u user and try to establish a ssh connection (although in targeted mode it is not that much meaningful): $ useradd -Z guest_u alex (took time because there are labeling happening in background), $ passwd alex, su - alex, reset system and login with alex user, $ id -Z, now let’s test, $ su - root (failed), sudo cat /etc/shadow (failed), ping 8.8.8.8 (failed), could be changed $ usermod -Z staff_u - $ semanage login -l —> show all user mappings of system - $ seinfo —role : (15 roles) - auditadm_r - dbadm_r - guest_r - logadm_r - nx_server_r - object_r - secadm_r - staff_r - sysadm_r - system_r - unconfined_r - user_r - webadm_r - xguest_r - $ seinfo —type | nl —> 4932 types - Booleans are policies that are watching system for security. Combining with contexts, it’s another layer for security (Defence in depth) - $ semanage boolean -l | nl —> 338 booleans. (on : runtime , on : permanent) - $ getsebool httpd_enable_cgi (runtime) | $ getsebool -P httpd_enable_cgi (permanent) - $ setsebool httpd_enable_cgi 0 (runtime) | $ getsebool -P httpd_enable_cgi 0 (permanent) - if an attacker could attack and get root permission, first thing he’d do is set selinux to permissive mode becaues he cannot disable it, since it needs reboot and makes lots of noise - $ setsebool secure_mode_policyload 1 —> after all configurations done, do this so no one (even root) can’t change SELinux to permissive mode. If done this Permanently and in runtime and you want to change it, should disable SELinux, then change it, then enable it again. - $ setsebool secure_mode_insmode 1 —> most of complex linux attacks are module-base. hackers insert modules into kernel, so there codes are being run in kernel space. to disable any further a do, we secure insmode, after making it true, no modules could be added or inserted by process/user. If this is on, wireless could have problems, because it has to load multiple modules - $ setsebool deny_ptrace 1 —> attackers inject some malicsous activity to processes. they do so by injecting to the process 1 for example, it is almost impossible to find some of binded process injections. one of tools to do so is by ptrace (which is a tool for debugging software that a developer developed) - $ setsebool deny_execmem 1 —> Don’t let a user/process execute code directly from RAM - $ vim /etc/selinux/targeted/contexts/files/file_contexts —> all of labels for contexts. there are lots of regexes set there. should be noticed that latter rule overrides first one - $ vim /etc/selinux/targeted/contexts/files/file_contexts.local —> all of labels for contexts that are added by sysadmin - for managing file system labeling: - $ chcon —> Temporary Change (run time). [could use -R for recursive changes] $ chcon -t ssh_home_t a.txt - $ semanage fcontext —> Persistant Change. [could use -R for recursive changes]. $ semanage fcontext -a -t ssh_home_t /etc/z.txt —> add this rule to config file: any time a z.txt created in etc, type of it will be ssh_home_t. $ semanage fcontext -d -t ssh_home_t /etc/z.txt —> delete this rule from config file - $ restorecon —> relabel run time configs to persistant configs. [could use -R for recursive changes]. $ restorecon -v /etc/z.txt —> relabel using verbos. $ restorecon -n -v /etc/z.txt —> simulate relabeling without actually changing context. - Scenario: set a new DocumentRoot for apache: open config file of apache $ vim /etc/httpd/conf/httpd.conf, change document root to “/web”, change line number 122 and 134, $ mkdir /web, echo New Page > /web/index.html, $ systemctl restart httpd, $ curl 127.0.0.1/index.html [403 Error forbiden], first step is setting DAC then MAC, $ ls -ld /web/, $ chown -R (recursively) apache:apache /web, $ ls -ld /web/, now let’s set MAC, $ ls -ldZ /web/, solution 1 for finding right type to be given : ls -lZ /var/www/html/ —> type is httpd_sys_content_t, solution 2 : vim /etc/selinux/targeted/contexts/files/file_contexts and then search in vim /www, now lets give it the proper type $ semanage fcontext -a -t httpd_sys_context_t “/web(/.\*)?”, $ restorecon -R -v /web - Scenario: set a new HomeDir : open config file $ vim /etc/httpd/conf.d/userdir.conf, line 17 : UserDir enabled, uncomment line 24 : UserDir public_html, $ systemctl restart httpd, $ su - hacker, mkdir public_html, $ echo hacker page > public_html/index.html, $ curl 127.0.0.1/~hacker/index.html [403 Error forbiden], $ su - , first set DAC properly $ ls -ld /home/, ls -l /home/, $ setfacl -R -m u:apache:rwx /home/hacker/, $ getfacl /home/hacker/, $ curl 127.0.0.1/~hacker/index.html [403 Error forbiden], now set MAC properly $ ls -lZ /home/hacker/, its set allright, lets check booleans $ semanage boolean -l | grep httpd, $ setsebool httpd_enable_homedirs on, $ setsebool -P httpd_enable_homedirs on, $ getsebool httpd_enable_homedirs - SELinux doesn’t deny pid=1 things, if an error happens on pid=1, it only logs it and not stop it from working - all of SELinux logs are in auditd daemon. SELinux logs have type=AVC (Access Vector Cache) - See SELinux Log: - raw form : $ cat /var/log/audit/audit.log | grep -ia avc —> seeing all of selinux logs in it raw format (not recommended) - sealert : $ sealert -a (analyze) /var/log/audit/audit.log, it shows description of what has happend, consider that Source is process and Target is file - ausearch (audit search, not SELinux specific) : $ ausearch -i (interpret) -m (for getting key) avc - audit2why : $ ausearch -i -m avc | audit2why —> it is the most analyctical one with showing lots of info and possible solution - If after tuning, searching, reading logs, you couldn’t still set up a service correctly, you can set the domain to permissive rather than complete SELinux system - $ semanage permissive -l —> see permissive domains - $ semanage permissive -a (add) httpd_t —> make all of httpd permissive - all services have specific ports - Scenario : change default port of apache : $ vim /etc/httpd/conf/httpd.conf, port 800, $ systemctl restart httpd, & netstat -antp | grep 800, $ ausearch -i -m avc | audit2why, let’s see all of ports $ semanage port -l, $ semanage port -a 800 -p tcp -t http_port_t - for removing any semanage thing use -d flag ——————————————— [4- SSH Hardening, Fail2ban, TCP Wrapper, NGINX, Kernel Parameters Hardening] **SSH Hardening**: - metasploit is a tool for offenssing ssh. $ msfconsole . $ search mikrotik, $ search ssh_login, $ use auxiliary/scanner/ssh/ssh_login, $ show options, RHOST means remote host address, RPORT means remote port, $ set RHOSTS 127.0.0.1, $ set user_file ~/user.txt, $ set password ~/pass.txt, $ set verbose true, for running you can $ run OR $ exploit, this way you can brute force - Scenario : SSH using public key : - 1- generate key pairs, $ ssh-keygen -t rsa -b 4096, default place to save this key pair is /home/hacker/.ssh/id_rsa, it ask for a passphrase which is for private key, check out key randomart, $ ssh-keygen -l (viewing fingerprint) -v (visualized randomart) -f (file) id_rsa.pub - 2- Transfer public key to host, $ ssh-copy-id [hacker@127.0.0.1](mailto:hacker@127.0.0.1), first time you connect to a machine via ssh, it show the fingerprint of it with algorithm of it for being sure you are connecting to right machine - 3- private key used to sign a challenge and generate a message - 4- message transferred to host PC - 5- Message authenticity verified using public key, and access is granted - fingerprint of the machines we want to connect to are being saved in /home/hacker/.ssh/known_hosts - pub key of users that can connect to the machine via ssh are being save in /home/hacker/.ssh/authorized_keys - Disabling weak ssh encryption algorithms: - Ciphers: Symmetric algorithms (AES, 3DES) - HostKeyAlgorithms: public key algorithms for authentication between machines (RSA, ECDSA) - KexAlgorithm: method of exchanging symmetric keys after HostKeyAlgorithms did their job (Diffie Hellman) - MAC: hashing, for integrity purposes - vim /etc/ssh/sshd_config —> - line 48 : PublicKeyAuthentication yes - PasswordAuthentication no —> Better than commenting is to write no, It will have higher score in openSCAP - line 43 : PermitRootLogin no - for adding ciphers, line 28 : Ciphers aes256-cbc,aes256-ctr - for adding KexAlgorithms, line 29 : KexAlgorithms ecdh-sha2-nistp384 - X11Forwarding no - SSH tunneling: (because if someont has attacked, can’t export data in a encrypted way) - line 105 : AllowTcpForwarding no - line 106 : GateWayPorts no - line 125 : PermitTunnel no - AllowStreamLocalForwarding no - Port 37000 - $ nmap —script ssh2-enum-algos -sV (version) -p 22 127.0.0.1 —> check all of algos a machine has for ssh - for disabling weak algos, should config crypto-policies, can find address of it from $ vim /lib/systemd/system/sshd.service, $ /etc/crypto-policies/back-ends/opensshserver.config, then delete undesired algos - setting white list in sshd config file : - DenyUsers : all have access except the one i’m declaring - line 147, AllowUsers : No one has access except the one i’m declaring —> AllowUsers root john - Automatic LogOut : - $ vim /etc/profile.d/logout.sh (there is no need to give this file execution permission since it is not in user space) —> - #!bin/bash - TMOUT=20 (this is second) - readonly TMOUT - export TMOUT - Setting Banner on server : - line 130 : Banner /etc/ssh/banner.txt - Mitigation of DOS attack : - line 124 : MaxStartups 10:30:60 (number of unauthenticated concurrent connections before we start dropping : percentage chance of dropping when reach 10 : maximum number of concurrent connections when start dropping everything) - MaxStartups 2000 (on 2000 concurrent connections start dropping everything ) **Fail2Ban:** - is a service that works on authentication based services such as ssh, … and could stop things from accessing desired service. - config file is /etc/fail2ban/fail2ban.conf but don’t touch it, if any changes wanna be happen, touch inside this directory /etc/fail2ban/jail.d - Fail2Ban : $ vim /etc/fail2ban/jail.d/ssh.local —> - [sshd] - enabled = true - port = ssh,22000 - banaction = iptables-multiport (if firewalld : firewallcmd-ipset) - logpath = /var/log/secure - maxretry = 4 (after 5 unsucccessful try, ban his ip) - bantime = 120 (second) - $ systemctl restart fail2ban.service - $ systemctl status fail2ban.service —> make sure its active (running) - $ fail2ban-client banned —> show banned IPs - $ fail2ban-client unban 192.168.56.1 —> unban this IP **TCP Wrapper:** - TCP Wrapper is deprecated by RedHat 8, libwrap is dynamic shared library behind of it. RedHat say to implement it in Firewall, Debian still got it. - For seeing if ssh module got it $ ldd /usr/sbin/sshd | grep libwrap - first implement allow then deny, there is no need to reload or reboot - $ vim /etc/hosts.deny : - SSHD: ALL **NGINX:** - Apache is thread-based, while nginx is worker-based. It stated C10K, 10K concurrent connection. - Master Process —> Child Process (on RAM) —> workers [as much as CPU cores] [workers have shared memory, because handling sessions] —> each worker has its own threads - workers have 1- Cache Manager and 2- Cache Loader —> rate limit, defining session - tip: if running nginx on SELinux, should make execmem boolean true + http_setrlimit - It loads stuff on RAM. - nginx consider each connection an openFile. - $ ps -aux | grep nginx —> shows master process and worker process. master is being run with root (because of priviledged ports), worker is being run with nginx. - $ curl -I [anisa.co.ir](http://anisa.co.ir) —> return header. if it is not hardened, version of nginx is going to be back in return - if you want to compile nginx and make version go away —> - $ vim /root/nginx/src/ngx_http_header_filter_module.c (c source code) —> line 49-50-51 - $ vim /root/nginx/src/core/nginx.h (header), for example change nginx to IIS - $ vim /etc/nginx/nginx.conf : - line 14 : events { worker_connections 4096;} —> (number of open files, for preventing slow http) - line 23 : http { server_tokens off;} (removing version) - controlling buffer overflow attacks : - http { - client_body_buffer_size 128k; - client_header_buffer_size 2k; - large_client_header_buffers 4 8k; - } - $ nginx -t —> to check whether we have syntax errors or no - timeouts to improve server performance : - client_body_timeout 30s - client_header_timeout 30s - keepalive_timeout 45s - what is XFF in header? imagine user send a request through CDN, then packet’s source IP is CND’s Ip and XFF is user’s IP - What is referrer in header? imagine someOne came to your website from searching in google, then referrer is google.com - limiting number of concurrent connections from a specific IP - http { - limit_conn_zone $binary_remote_addr zone=one : 10m; (just defining zone with name one and 10 megabyte storage) - server { (define it per server means for each web app, we could have different limits) - limit_conn one 40; (41st concurrent connection will be closed) - } - } - limiting request rate - http { - limit_req_zone $binary_remote_addr zone=two : 10m rate=250r/s; (just defining zone with name one and 10 megabyte storage) - location / { (define it per location means for each route, we could have different rate limits) - limit_req zone=two; - } - } - limiting request methods - location / { - limit_except HEAD POST { (just HEAD and POST are OK, deny all) - deny all; - } - } - limiting user agents (bad user agents especially, search github for bad bot user) - in enterprise places don’t do it because it has an overhead and has to open all packets and read for user agent of it - location / { - if ($http_user_agent ~_ (wget|curl|acunetix|mirai|nessus) ) { (~_ means case insensitive) - return 444; - } - } - $ curl —user-agent “jafar” -X GET 127.0.0.1 - avoid clickjacking by disabling <iframe> (iframe is a way to load another web site directly) - http {add_header X-Frame-Options SAMEORIGIN} - http {add_header X-Content-Type_Options nosniff;} —> if server say a something is a peace of text, then client should know it is text and nothing else. client trust servers advertised info about what is being sent - add_header X-XSS-Protection “1; mode=block”; - HSTS —> force user to go to port 443 (ssl) - CSP header **Kernel Hardening & Process Isolation:** - Kernel has 4 jobs : 1-Memory Management 2-Process Management 3-Device Drivers 4-System Calls & Security - There is no information about it anywhere. - There are 3 ways to modify these parameters : - 1- when building the kernel : in kernel’s config file - 2- when starting the kernel : using command line parameters, through a boot loader - 3- At runtime : through the files in /proc/sys/ —> vm : virtual memory - net : network - kernel - fs : file system - dev : devices - crypto : cryptographic - abi : application binary interface - $ cat /proc/sys/vm/swappiness —> 30 (means on 70% of memory goes to swap) - for changing there are 2 ways : $ echo 10 > /proc/sys/vm/swappiness - notice that sometimes when installing new ap p, app is going to need sudoer access and it is going to change lots of kernel parameters ——————————————— [5- Kernel Parameters Hardening, Lynis, Process Isolation & Limits, Control Groups, FireJail, Malware Detection] **Kernel Parameters Hardening:** - $ sysctl Tunable_Class.Parameter —> $ sysctl vm.swappiness : For viewing Kernel Parameters - $ sysctl -w (write) Tunable_Class.Parameter=value —> $ sysctl -w vm.swappiness=20 : For changing Kernel Parameters Temporarily - $ sysctl -a (all) : show all parameters - For Changing parameters Permanently, notice there is a sysctl.conf file, but we are not going to write in this one, since there is a sysctl.d file which is best practice to write on that : $ vim /etc/sysctl.conf - $ sysctl -w vm.swappiness=30 >> /etc/sysctl.conf - best practice is : $ sysctl -w vm.swappiness=30 >> /etc/sysctl.d/parameters.conf, and then set it right now (not in next reboot) via $ sysctl -p /etc/sysctl.d/parameters.conf - check out [sysctl-explorer.net](http://sysctl-explorer.net) for all of parameters with details - Parameters : - 1- kernel.kptr_restrict=2 —> list of all of virtual memory offsets that are loaded on RAM during run time. if =1 then list of all is available but mapping to memory is not showing and all users with SYSLOG capability can see all mappings, if =0 then restriction is disabled and all of pointings are being shown to every body, if =2 then only UID=0 (root) can see it. these informations are inside /proc/kallsyms - 2- kernel.dmesg_restrict=1 —> all users with $ dmesg command can view kernel ring buffer and its logs from booting till now. All of stack pointers and memory allocations when segmentation fault happened are visible. There is no need for users to see this information. - 3- kernel.printk=“3 3 3 3” —> shows kernel level prints/errors/info/log, are used in kernel/driver development. its default is 7(console_logLevel : show logs that developer intended them) 4(default_message_logLevel : if the app/process has not defined logLevel, then it should be this) 1(minimum_console_logLevel : minimum value user could set for console log) 7(default_console_logLevel : boot time logs) | infected systems could gather lots of information just by logs. It is best practice to Log at a practical minimum level | 0 is higher and 7 is lowest | 0 —> KERN_EMERG (emergency) : when system/process crash, 1 —> KERN_ALERT : showing user in console that you have to do something right now, if you do not, then your system is going to crash, 2 —> KERN_CRIT (critical) : when having critical error, SoftWare or HardWare level Errors, 3 —> KERN_ERR : kernel error, lesser priority, not critical errors, systems not gonna crash if the problem is not resolved, for example when you attached something to system and its driver is unknown, 4 —> KERN_WARNING : for security purposes from this level down below is not important, just good for debuging, for example you are running out of space in stack, 5 —> KERN_NOTICE : there is no errors here, just system events are there, 6 —> KERN_INFO : informational messages, 7 —> KERN_DEBUG : lots of logs are being generated - 4- kernel.kexec_load_disabled=1 : what kexec does? it loads another kernel in current kernel in runtime, if system is compromised anyhow, attacker could run a kernel within the system and have access and rootkit to every thing - 5- kernel.sysrq=4 —> system request, is on screen shot key of keyboard, there are key combos on your keyboard that when you hit them, a signal is going to be sent to kernel and something’s gonna happen, for example CNTRL+C is SIGINT, CNTRL+Z is SIGCSTP (stop executing ready to countinue), alt+sysrq(screen shot)+b —> reboot, alt+sysrq(screen shot)+c —> crash + coredump (a snapshot of memory) | 0: disable completely, 1: enable completely, >1 : bitmask of allowed functions, 2 (0x2): enable control of console logging level, 4 (0x4): enable control of keyboard (SAK, unraw), 8 (0x8): enable debugging dumps of processes etc., 16 (0x10): enable sync command, 32 (0x20): enable remount read-only, 64 (0x40): enable signalling of processes (term, kill), 128 (0x80): allow reboot/poweroff, 256 (0x100): allow nicing of all RT tasks - 5.5- for disabling coredump : first lets see its value $ sysctl -a | grep coredump, now lets disable it $ sysctl -w kernel.core_pattern=“|/bin/false”, some app with suid set can bypass this, so lets make sure $ sysctl -w fs.suid_dumpable=0 - 6- net.ipv4.tcp_syncookies=1 —> set cooky of tcp connection, in order to TCP queue to not be full, and DOS attack happens - 7- net.ipv4.tcp_rfc1337=1 —> in tcp in general, after a connection is ended, tcp connection is being open until sometime after in order to if any how any packet was not transmitted right, chance for re-transimitting it still exists, in DOS/DDOS attacks connection remaining open is not good at all, if this parameter is set to 1, then tcp connection is ended after a FINACK is sent. - 8- net.ipv4.conf.all.rp_filter=1 , net.ipv4.conf.default.rp_filter=1 —> reverse path check all of interfaces for if the packets source exist and is available before processing its packets. ip spoofing, where attacker set an unvalid source ip (martian IPs) on packets it sent. default paramaeter means if a new interface added to system, it reverse path is being enabled. - 8.5- net.ipv4.conf.all.log_martians=1 —> log all packets that are comming from martian IPs, which are pre set and attackers usually put these IPs on their packets source - 9- net.ipv4.icmp_echo_ignore_all=1 —> first thing an attacker does is sending ICMP packets to wide amount of ip range to find which systems are live in network, it could be good to don’t let others ping our system. should note that Zabbix use ICMP for checking stuff and if this is set, it could get broken. - 10- net.ipv4.tcp_sack=0 , net.ipv4.tcp_dsack=0 , net.ipv4.tcp_fack=0 —> when a tcp connection is established, there are windows of packets that are being sent. sack means if for example window is 20 and 18-th packet is not received by destination, only send 18-th one again not whole 20 packets. - 11- net.ipv4.ipfrag_low_thresh , net.ipv4.ipfrag_high_thresh —> there is a part in RAM which is dedicated to reassembling of packets that are fragmented, It is best practice to make it higher than default. make it 8-11 MegaBytes (8388608) for high and 8 MegaBytes (8388608) for low - 12- net.ipv4.tcp_max_syn_backlog=4096 —> its values are not byte, they are Intejer. It refers to value of TCP queu for each port. its default is 128 which is very low, someone could send 128 packets and then TCP Queu is full and 129-th packet is being rejected with RST - 12.5- SoMaxConn —> for established connections - 13- net.ipv4.tcp_synack_retries=3 —> how many times I can respond to a SYN for SYNACK. It is going to send 6 packets in 6 different time intervals, 1s 3s 7s 15s 31s 63s - 14- net.ipv4.tcp_keepalive_time=2000 —> How many seconds i keep the connection alive if connection is inactive and nothings being transmitted. - 15- net.ipv4.tcp_keepalive_probes=4 —> how many probes sent before declaring the connection dead. this probes are being sent when former keep_alive_time is finished - 16- kernel.randomize_va_space=2 —> randome addresses for heap, stack, code. 1 & 2 are both enabled but 2 has compilde code in data segment randomization too - 17- kernel.yama.ptrace_scope —> ptrace is usually for debugging but attackers could use it for binding there malicsous code to a certain PID, there is even ability to permanently do that, or be binding on boot time. 0 means do nothing , 1 means disable it, 2 means only root user can dot this for a process that is currently running - 18- kernel.threads-max=10000 —> number of threads that could be running on server - 19- how to disable CNTRL+ALT+DELET : solution1: systemctl mask ctrl-alt-del.target, solution2: sysctl kernel.ctrl-alt.del - 20- kernel.watchdog **Lynis:** - It’s a tool for checking system’s hardening parameters. - It is good for dockerized environments - $ lynis audit system —> for scanning system - $ lynis show details KRNL-5820 —> to show details about error/warning/suggestions that Lynis creates **Process Isolation & Limits:** - $ ulimit -a —> show all limits - $ ulimt -u 100 —> for example for changing soft limit in hard limit boundaries, could be used this command - $ vim /etc/security/limits.conf —> this is used for resource limitation, somehow deprecated, it has 5 fields that must be defined : - <domain> : hacker - @hacker (group) - \* (all) - 1000:1005 (uid between 1000 and 1005) - 1000: (for all real users except root) - <type> : soft means user-space & is default of what user have when he logs in, hard means kernel-space & is kinda maximum that user/process could go up to - <item> : - <value> : could be unlimited - for example for disabling core-dump : _ soft core 0 + _ hard core 0 - for limitting number of concurrent processes for a user : hacker soft nproc 40 + hacker hard nproc 1000 - How to limit other users to not see others processes usiong $ top or $ps -aux ? inside /etc/fstab add this line: proc /proc proc hidepid=2 0 0, then $mount -a, $mount -o remount proc. What is difference between hidepid=1 vs 2? if 1, then you can see pIDs in /proc but you can’t open them, in 2 you can’t even see them, processes are isolated **Control Groups:** - its systemd-level, could have isolation & limitation seprately. sockets, I/O, users, processes. for security and management purposes - $ systemctl set-property httpd.service CPUAccounting=1 MemoryAccounting=1 BlockIOAccounting=1 —> first you have to enable accounting then you could set limitations. - for viewing all accountings and its values —> /etc/systemd/system.control/ - $ systemctl set-property httpd.service CPUQuota=30% MemoryLimit=500M —> set limitations - $ systemctl set-property user-1000.slice CPUAccounting=1 MemoryAccounting=1 - $ systemctl set-property user-1000.slice CPUQuota=30% MemoryLimit=1G - $ dd if=/dev/zero of=/dev/null bs=1M & —> fake cpu usage for benchmarking - should be log out / restart for making changes - could use limitations and CGroups to stop fork bombs attacks that made system hang **Sandboxing with FireJail:** - making isolated environment. if there is a suspicous binary or app open that in here - it is profile-based. - it has a PID and isolate that process entirely **Malware Detection:** - LMD: linux malware detection - **we are using LMD + ClamAv (clamd)** - for configuring it $ vim /usr/local/maldetect/conf.maldet - email_allert=“1” - email_address=”[examle@example.com](mailto:examle@example.com)” - line 50 : autoupdate_signature=“1” - line 58 : autoupdate_version=“1” - line 71 : cron_prune_days=“30” —> after how many days delete isolated malwares that are kind of like logs - line 76 : cron_daily_scan=“1” —> scan every day - line 104 : scan_max_depth=“21” —> how many directories should i go down. Best practice to make it 21 because of in depth directories. attacker knows maldet is default to 15, so make 16 directories and bypass maldet - line 108 : scan_min_filesize=“19” - line 115 : scan_max_filesize=“8M” - line 141 : scan_clamscan=“1” —> use clamd as an other engine to be better - line 173 : scan_ignore_root=“0” —> if a file is owned by root, dont bypass scanning - $ freshclam —> update clamAV - $ maldet -u —> update maldet - $ maldet -a (analyze) /home —> scan directory - $ maldet —report [SCANID] —> see report that is generated - $ maldet -e list —> show all reports that have generated - $ maldet -r /var/www/html/a/upload 7 —> scan this directory for files that are created/modified for last 7 days **root kit hunter : ** - $ rkhunter —update - $ rkhunter -c (check) --cronjob —rwo —> scan all system, cronjob means you don’t have to press enter in middle of scan for countinuing process, rwo means just show warnings/errors **AIDE (advanced Intrusion Detection Environment)** - Integrity checking. it is scanning all system and make a DB full of hash of all of files that system contains. then on second time that you scan system, it is going to compare DB2 with DB1 for all of files that are modified. - also after attack it is good for analyzing what has been part of attack. - $ aide —init —> it start scanning - $ vim /etc/aide.conf —> config file - line 91 : assign directories that want to scan, with sort of scan parameters it should have - ! IMPORTANT ! : first time that you scan change name of DB that it makes : $ cd /var/lib/aide/ $ mv aide.db.new.gz aide.db.gz —> this is because comparing is based on two files, aide.db.gz : main file (DB1), aide.db.new.gz : main file (DB2) - $ aide —check —> just show files that have modified, create DB in RAM - $ aide —update —> show files that have modified, create DB in /var/lib/aide ——————————————— [6- auditd, dnssec, OpenSCAP] **AuditD:** - auditd is a component of kernel. Can log Everything. - It is being used by auditctl, being searched with ausearch & for generating report you can use aureport. its config file is in /etc/audit/auditd.conf, there is no need to make changes, rules can be written in /etc/audit/audit.rules. address of logs are /var/log/audit/audit.log - $ vim /etc/audit/audit.rules —> there is by default this values there, don’t change them in any situatino, they are good, you can add rules below them but it is best practice to add rules in another file : - -D —> delete all of rules that are being written in RAM - -b 8192 —> how much is my audit buffer in kernel memory - -f 1 —> failure mode, 0 : when audit failed do nothing, 1: when failed printk(), 2: when failed panic - —backlog_wait_time 60000 —> low level concept, what my frequency (hertz) would be for your auditd - $ auditctl -l —> see rules that are loaded on system - $ auditctl -w (watch) /etc/shadow -p (permisiion) rwxa (read/write/execute/change attribute) -k (key) SHADOW_CHANGED - for permanenting rules : $ auditctl -w /etc/shadow -p w -k SHADOW_CHANGED >> /etc/audit/rules.d/askari.rules - for a basic seeing of logs you can : $ cat /var/log/audit/audit.log | grep -ia shadow_changed - $ ausearch -i (interpret) - k SHADOW_CHANGED —> seeing logs - $ ausearch -i -x useradd —> for searching using command that was executed - $ ausearch -i -ua 1000 —> for searching using logined user - $ ausearch —event 562 —> for finding event - Log fields : - type: SYSCALL - USERLOGIN - USERLOGOUT - ADDUSER - ADDGROUP - AVC - CWD - PASS - PROCTITLE, … - msg: by whom and when this log was created : audit(166723324 (epoch time, for converting epoch time using terminal —> $ date -d @1671122464):149 (event id, for each event auditd assign an id because it is easier to search in it this way)) - arch: cpu aarchitecture - c000003e for x86/64 - syscall: number of syscall that caused this log to happen - could find syscall using its number : 1- searching in $ vim /usr/include/asm/unistd_64.h 2- $ ausyscall —dump - success: [systemic atrr] has syscall finished successfully or not - exit: [systemic atrr] return code of syscall to the kernel. has nothing to do with famous app exit code - a0 a1 a2 a3: [systemic atrr] hex arguments of syscall - items: [systemic atrr] how many pass auxiliary records existed in syscall - ppid: parent process id - pid: process id - auid: audit user id, login id, with which user was logined to system in first time - uid: user id - gid: group id - guid: group user id - euid: effective user id - suid: set user id - fsuid: file system user id (for file sharing in network) - egid: effective group id - sgid: set group id - fsgid: file system group id (for file sharing in network) - tty: console kind - ses: [systemic atrr] what was session id of process that was invoked that caused this log - comm: what command was hitted - exe: executable path of command - subj: SELinux Context - key: key of log - IMPORTANT : uid=-1/unset/40,000,000 means it is systemic user - $ aureport —start 03/17/2022 00:00:00 —end 01/14/2023 00:00:00 - $ aureport -x —> create executable report - $ aureport —summary —> create مدیریتی report - $ aureport -i —login —> create report of who has logged in - $ aureport -i —login —summary - for writing rules in auditd, it is like firewall that adds from above to below, and order of it matters - auditctl -a (append this rule below all rules) -A (append this rule above all rules) action (what to do about this syscall, values are : always - never), filter (different values —> task : is systemic and rarely used, when fork() or clone() was executed by a parent then log - exit : by the time system call is exiting do this log - user : filter events that are originated in user space - exclude : dont show this as log, like never in action) [mostly always, exit] -S system_call -F field=value -k key_name - SCENARIO : defense evasion, Persistence, Privilege Escalation, Initial Access (T1078 MITRE ATT&CK): - $ auditctl -a always,exit -F arch=b64 -F path=/bin/su -F perm=x (execute) -F “auid>=1000” -f “auid!=-1” -k T1078_PE - SCENARIO : log all commands a user execute - $ auditctl -a always,exit -F arch=b64 -S execve -F “auid=1000” -k HACKER_EXEC —> it is very noisy, don’t do it for all the time - tip: $ file echo —> it is a shell built-in, not going to call execve syscall - SCENARIO : log all commands a systemic user execute, in order to find whether it is hacked - $ auditctl -a always,exit -F arch=b64 -F path=/etc/passwd -F perm=war -k PASSWD_CHANGE - $ auditctl -1 always,exit -F arch=b64 -S ptrace -k PROCESS_INJECTION - (test this one, was not working) $ auditctl -a always,exit -F arch=b aas64 -S open -S openat -F exit=-EACCES -k PERM —> when ever a user tried to open a file that haven’t had permission to, log it. open/openat syscalls are for opening files and EACCES is error that is being sent with permission denied so if you have to also watch /etc/sudoers file **DNSSEC:** - DNS protocol wasn’t secure in first place. - DNS Atatcks : - NX Domain - Phantom domain - Rebinding attack - Lock-up attack - DRDOS - Cache poisoning - DNS hijack - Random subdomain attack - DNSSEC allows : verification of integrity of each record - validation that the record originates from the authoritative DNS server for the record (authenticity) - chain of trust - what is NX record? it is the record that DNS sends when the domain is not resolved, means there is no info about this domain in DNS - DNSSEC adds a new record to DNS : RRSET (resource record set), it is bundling all alike records, for example all MX records are being bundled together, all AAAA records are being bundled together, and then each bundle is being signed. This is good for performance and also security. - ZSK (zone signing key): first key DNS generates. - RRSIG —> RRSET signed with private key of ZSK - DNSKEY —> public key of ZSK + public key of KSK, signed with private key of KSK - KSK (key signing key): to validate ZSK - steps: - client asks for resolving a domain - DNS returns RRSIG + DNSKEy - client asks for public key of KSK in order to verify DNSKEY - DNS returns public key of KSK - DS (dedication signer): hashed public key of KSK, for chain of trust - we are going to implement it using chroot, it is a defense in depth method for jailing system, what it does is replicating everything bind needs from system to a local / directory and then isolating it, when attacker comes thinks / is main root directory, but he’s wrong : - $ rpm -aq | grep chroot - $ dnf install bind-chroot - directories gonna change : - /etc/named.conf —> /var/named/chroot/etc/named.conf - /var/named —> /var/named/chroot/var/named - $ systemctl stop named - $ systemctl start named-chroot - /var/named/chroot/etc - get this script for automation of slave —> - $ wget [https://kernel110.com/named.conf](https://kernel110.com/named.conf) - $ wget [https://kernel110.com/iran.ir.db](https://kernel110.com/iran.ir.db) - $ cp -f named.conf /var/named/chroot/etc/ - $ cp -f named.conf /var/named/chroot/var/named - $ echo “nameserver 127.0.0.1” > /etc/resolv.conf - $ chattr +i /etc/resolv.conf - $ systemctl stop firewalld - $ systemctl disable firewalld - $ dig mx [iran.ir](http://iran.ir) - notice that chroot mount files, because of security level of things, it is making a virtual file system and then mount files, so you can’t change or modify files. if any modification want to be made, should stop chroot and then edit and the start it again. - $ mv named.conf.1 named.conf - $ /usr/libexec/setup-named-chroot.sh /var/named/chroot/ on—> a bash script which is copy all requirements of our jailing. so duplicate some files and libraries to inner / so service could work completely isolated - $ vim named.conf: - line 11 : acl AllowQuery { 192.168.56.0/24; }; : for setting access control and not letting anybody to change it - line 13 : listen-on-v6 port 53 {none;}; - line 21 : allow query { any; }; —> {AllowQuery;}; - line 66 : allow-transfer { 192.168.56.104;}; : for allowing transfer to slave - $ named-checkconf /var/named/chroot/etc/named.conf —> it checks whether or not config is in right syntax - $ dnssec-keygen -a NSEC3RSASHA1 -b 2048 -n ZONE [iran.ir](http://iran.ir) —> NSEC is a protocol which in case there is no domain to return, dns send before and after of those domains, but in a hashed way - $ dnssec-keygen -f KSK -a NSEC3RSASHA1 -b 2048 -n ZONE [iran.ir](http://iran.ir) - $ echo “\$INCLUDE /var/named/chroot/etc/[Kiran.ir](http://Kiran.ir).+007+22757.key” >> /var/named/chroot/var/named/[iran.ir](http://iran.ir).db - $ echo “\$INCLUDE /var/named/chroot/etc/[Kiran.ir](http://Kiran.ir).+007+57339.key” >> /var/named/chroot/var/named/[iran.ir](http://iran.ir).db - $ dnssec-signzone -A -3 $(head -c 1000 /dev/random | sha1sum | cut -b 1-16) -N INCREMENT -o [iran.ir](http://iran.ir) -t /var/named/chroot/var/named/iran.ir.db —> A: algorithm NSEC3 , 3: salt or random string, here we are running a script inside our script, N : increment version of SOA, o : origin, which zone, t : verbose - $ vim /var/named/chroot/etc/named.conf.local —> - zone “[iran.ir](http://iran.ir)” { - type master; - file “/var/named/chroot/var/named/iran.ir.db.signed”; - allow-transfer { 192.168.56.104; }; - also-notify { 192.168.56.104; }; - auto-dnssec maintain; —> periodically check, other option is allow - }; - DNSKEY 256(ZSK, 257 : KSK) 3(DNSSEC 3) 7(algorithm type) - $ dig DNSKEY @192.168.56.102 [iran.ir](http://iran.ir) **OpenSCAP:** - compliance testing (تست انطباق پذیری) using for auditing. based on profiles tailored from specialists and cmopanies in security. - it is an standard - SSG (scap security guide) : profiles for testing by companies and foundations. famous ones: PCIDSS (Banking industries), DISA-STIG (Enterprise Network Infrastructure), CIS, ACSC (Australian Cyber Security Centre), HIPPA (Health Insurance Portability and Accountability Act). xml format - use DISA-STIG - it is possible to create a profile by yourself - in installing os, you can go forward using scap profiles. it is going to ask you for hardening step by step during installation. - there are two forms of data model in security, imagine there is a firewall and a microsoft server and a linux server, logs of them are very different, for gathering all logs together there should be a protocol/data model. we should choose one for using. - XCCDF (Extensible Configuration Checklist Description Format) - OVAL (Open Vulnerability and Assessment Language) - CPE (Common Platform Enumeration) : for each os there is a number assignes, so referencing is easier. for example redhat 8.6 has a CPE - CVE (Common Vulenarabilities and Exposures) : - CWE (Common Weakness Enumeration) : it is a simple way for refrencing CVEs to everyone in tech industry. for example CWE-121 is related to stack overflow, one could see lots of info about that when search it - $ oscap info ssg-rl8-ds-1.2.xml —> show info, ds-1.2 is better because has lots of things inside. it is about 35000 lines of code - copy id of desired profile from last command - $ oscap info —profile xccdf_org.ssgproject.content_profile_pci-dss ssg-rl8-ds-1.2.xml —> see all profile info with a little bit of description - $ oscap xccdf eval —results output.xml —profile xccdf_org.ssgproject.content_profile_pci-dss ssg-rl8-ds-1.2.xml —> evaluate based on profile and save result in output.xml, output.xml is about 250000 lines - $ oscap xccdf generate report output.xml > report.html —> create a human readable interactive report - below 60 score results in isolating system in network - $ oscap xccdf generate guide —profile xccdf_org.ssgproject.content_profile_pci-dss ssg-rl8-ds-1.2.xml > guide.html —> shows all of checklist that profile uses + lots of best practices on how to harden stuff, it is good for finding elements for creating your own list - IMPORTANT : Don’t use remediate (a tool that oscap automatically corrects the whats wrong) - $ oscap xccdf eval —remediate —profile xccdf_org.ssgproject.content_profile_pci-dss ssg-rl8-ds-1.2.xml **OpenVAS:** - volunarability assessment (ارزیابی آسیب‌پذیری) - main core of openVAS is GVM (Greenbone vulnerability Manager), it accepts user data, scap cert is for openscap profiles, NVT (network vulnarabilty test) is field of greenbone, NVTs on free version is updated monthly but in commercial is very fast, OSP (open scanner protocol) scanner is a framework that has lots of other scanners APIs and can export them and pass them to GVM, GMP (greenbone management protocol) Clients is making data standardized and viewable, it is xml based, using GreenBone Security Assisstant it could be make it html viewable ——————————————— [7- OpenVAS, Securing user accounts, PAM, Suricata] **OpenVAS:** - volunarability assessment (ارزیابی آسیب‌پذیری) - when scanning using openVAS, should turn antivirus off. so its a great machine for exploit and attacks. - scan —> new task - recommendation is using built-in openVAS on kali linux. should do these commands - $ sudo -u gvm greenbone-feed-sync —type CERT —> update cert advisories - $ sudo -u gvm greenbone-feed-sync —type GVMD_DATA —> update cve - $ sudo -u gvm greenbone-feed-sync —type SCAP —> update scap - $ sudo -u gvm greenbone-feed-sync —type NVT (if not worked this command instead $sudo -u gvm greenbone-nvt-sync ) —> update nvt **Securing user accounts:** - for working with /etc/sudoers its best practice to use visudo because it does syntax checking, but vim could also be used - users with /bin/bash are dangerous - $ visudo /etc/sudoers - Defaults !visiblepw —> pasword is not visible in terminal - Defaults env_reset —> reset environment variables - Defaults timestamp_timeout=3 —> after 3 mins require sudo password, default is 5\. it could be 0 : it will ask password every time. -1 : never expire password so if once entered then don’t ask for password again. - Defaults:john timestamp_timeout = 2 —> only for user john do this - line 100 : root (user) ALL(host, in centralized 100 systems there are 100 root users, which one )=(ALL(by whom user’s accessibility can execute):ALL(only debian has this, by whom groups’s accessibility can execute)) ALL(what command) - when an attacker exploit a machine it is adding his own user to this like this, so there is no need to add himself to wheel(red hat)/sudoer(debian) group : mysqld ALL=(ALL) ALL - john ALL=(ALL) /usr/bin/systemctl —> john user can do sudo all systemctl commands - john ALL=(ALL) /usr/bin/systemctl restart \* —> john user can do sudo systemctl restart - john ALL=(ALL) /usr/bin/systemctl restart httpd, /usr/bin/systemctl restart sshd - john ALL=(hacker) /usr/local/sbin/data.sh —> john user can execute data.sh with hacker accesability, then run it like $ sudo -u hacker /usr/local/sbin/data.sh - %john ALL=(hacker) NOPASSWD: /usr/local/sbin/data.sh —> for group john (group defined with %), it has risk since you are bypassing password, don’t do it - john ALL=(ALL) sudoedit /etc/ssh/sshd_config —> you can open a bash terminal with root very easily. - sudo -l —> see all sudoers accessabilities that user has **PAM:** - when you are developing an API(app)/SPI(service), it is best practice to use PAM library for authentication & authoriztion instead of secure coding. it has these modules: - Authentication service modules - Account management modules - Session management modules - Password management modules - you are not going to config these modules, you are just going to call these methods - there is no need to restart anything. but if app/service is modified must restart - ldd /usr/sbin/sshd | grep pam —> seeing if app/service has used pam - system-auth and password-auth are exactly same, system is for console (tty-pts-…) & password is for remote (ssh-telnet) - $ vim /etc/pam.d/system-auth (for example system-auth) - first row: [module interface] - auth : identity of user is right, are username and password ok? - account [account validity] : check for validity of account, acoount is ok not disabled valid unlocked - pasword [updating password] : is user allowed, does this pass has complexity - session [session management] : setting environment, home directory initialization, flush keys when session is ended - second row: [control flag] - requisite (strongest flag) : if failed, don’t proceed any furthor - required : if failed, proceed and then after all modules checked in end show error - sufficient : if it passed, there is no need to check further modules - optional : ignore errors - default : - third row: [modules] (see all modules in $ ls /lib64/security/) (for info of each module $ man pam_env) - pam_env.so —> - pam_unix.so —> check /etc/shadow & /etc/passwd for user and password - pam_deny.so —> return error, failed - pam_pwquality.so —> password quality checking - fourth row: modules options, could find info about it in modules man - nullok : it is ok for pass to be null - try_first_pass : first pass that user entered at first module is being checked for this, if not passed ask for password - $ vim /etc/security/pwquality.conf —> can perform password quality from here too - SCENARIO : ssh bruteforce prevention using pam_faillock - $ vim system-auth - line 2 : auth required pam_faillock.so preauth (history of failed enters matters) silent (don’t show that has entered many times with wrong password) audit (log with printk) deny=5 (return error if tried more than 5 times) fail_interval=400 (lock user if 5 times wrong password in 400s ) unlock_time=400 (seconds) - line 4 after pam_unix.so try_first_pass: auth required pam_faillock.so authfail audit deny=5 unlock_time=400 - last line of account : account required pam_faillock.so —> lock account for 400s, because it is targeted - $ cp system-auth password-auth - $ faillock —> show all locked users - $ faillock —user john —> info about a specific user - $ faillock —user john —reset —> unlock - SCENARIO: two step authentication using google authenticator for ssh - HARDENING: $ vim /etc/pam.d/system-auth, in pam_unix.so : - remove nullok - add remember=10 —> can’t use passwords that have been used in previous 10 times **Suricata:** - open source intrusion detection system (IDS) & intrusion prevention system (IPS) & network monitoring system (NSM) - 10 core cpu, 20GB RAM, for enterprise environments - suricata is good for inside network attacks, so it is not like a firewall which is on edge of network - best practice is to port mirror all traffic of our network on a stand-alone server which has suricata on it, so it can perform all - $ cd /etc/suricata/ - classification : classes for suricate - refrence : from where rules are being get. list of DB sources - suricata.yaml : config file - /rules/ : built-in rules/signatures for detecting protocols - $ vim /var/lib/suricata/rules/suricata.rules —> file of finding rules - $ suricata-update —> updating signatures - $ suricata-update list-sources —> show all sources - $ suricata-update list-sources —free —> show all free sources - $ suricata-update list-enabled-sources —> show all enabled sources - $ suricata-update enable-source tgreen/hunting —> enable this source - $ suricata -T —> test & check if everything is ok. - $ vim /etc/suricata/suricata.yaml - HOME_NET : all IPs that are mine - EXTERNAL_NET : not my asset - af-packet (very low level network packet) - interface : enp0s8 - threads: auto (auto = as much as cpu cores - LRO: network card makes bundles, so they are going for processing in cpu. should be disabled for suricata. —> $ ethtool -K enp0s8 gro off lro off - GRO : for times LRO couldn’t be done - $ vim /etc/sysconfig/suricata - OPTIONS=“-i enp0s8 —user suricate” - IT IS NOW CONFIGURED. - $ ls /var/log/suricata/ - eve.json : all events are being logged. should be disabled - fast.log : all alerts - stats.log : every 8 seconds, create statistics. should be disabled - suricata.log : deamon log - writing rules is complex, but : - action : alert (IDS), pass, drop, reject - header : tcp (what protocol i’m working on) $HOME_NET (direction) any (source port) -> (<- or <> for both ways) $EXTERNAL_NET any - rule options : (msg{how should log it as event in fast.log}:”ET MALWARE Likely Bot Nick in IRC (USA + ..)”; flow: established,to_server; content:”NICK ”; depth:5; {inspect 5 layers inside packet} content:”USA”; within:10; reference:url,[doc.emergingthreats.net/2008124](http://doc.emergingthreats.net/2008124); classtype:trojan-activity; sid:2008124; {signature id} rev:5; metadata:created_at 2010_07_30, updated_at 2010_07_30;) - performance tuning - $ vim /etc/suricata/suricata.yaml - search for runmode, line 1063 : runmode: workers --> it is turning buffer into a single thread. instead of multithreading, which needs cpu usage to join results in the end - search for mpm, line 1492 : mpm-algo: hs --> what mpm-algo (Multi Pattern Matching) does is searching for rules/signatures inside. HyperScan is best option - search for profile, line 1438 : profile: high --> for performance related stuff, suricata bundles all signatures that are look alike - line 622: ring-size: 20000 --> how many packets could be saved in buffer, make it higher would result in not having queu - line 364: pcap-log: enabled: yes, compression: lz4, lz4-level: 4 (if have cpu, could go up to 16) --> when you are under attack, it gives you all flow of network in a pcap format - line 65: stats: enabled: no --> stats logs are disabled - line 87: eve-log: enabled: no --> eve logs are disabled - line 569: file: enabled: no --> eve logs are disabled **Bro (Zeek):** - could map all network flow. very useful tool ——————————————— [8- IPSEC, USBGuard, Reset Root Password & hardening GRUB2, Securing cronjob, FreeIPA] **IPSEC:** - IP is not a secure protocol. IPSEC is a collection of protocols, main one is IKE (internet key exchange) then SA (security association) which is managing keys, such as how much ttl should it have, how much live should it be - In IPSEC there is no client and server. There are left & right - IKE - phase1 (ISAKMP or IKE SA) : SA - Key exchange - Authentication - Phase2 (IPSEC SA) which has 2 modes : AH(not that popular, authentication - integrity - anti replay : not let man in the middle ) - ESP ( authentication - integrity - anti replay : not let man in the middle ) - In AH, there is sequence for preventing man in the middle and integrity and key - In ESP, if there is a man in the middle, he can understand to which destination IP this packet is going, but can’t understand what’s inside packet - It is possible to use AH and ESP together - IPSEC has two modes : - Transport : host to host, use packets original header - Tunnel : router to router, Firewall to Firewall, encapsulate entire packet, even packets header is not readable - For each connection/tunnel, there is a unique key pair needed - For implement it we use this package : libreswan - left & right : $ def install libreswan - left & right : $ systemic enable ipse —now - left & right : $ firewall-cmd —add-service=“”ipse - left & right : $ ipsec newhostkey —> create key pair - Left : $ ipse showhostkey —left —ckaid [id] —> show public key - Right : $ ipse showhostkey —right —ckaid [id] —> show public key - Left& right : $ vim /etc/ipsec.d/host-tohost.cong - conn mytunnel - leftid=@west - left=192.168.56.106 - leftrsasigkey=[pub key] - rightid=@east - right=192.168.56.104 - rightrsasigkey=[pub key] - left & right : $ systemctl restart ipsec - left & right : $ ipsec auto —add mytunnel - left & right : $ ipsec auto —up mytunnel - it is done! - for testing: - $ dnf install tcpdump - $ tcpdump -n -i enp0s8 host 192.168.56.104 **usbguard:** - good for bad usb. could easily find it on internet, for example it introduce itself as keyboard while it is not keyboard and going to exploit system - $ sudo pacman -S usbguard - $ cd /etc/usbguard/ - $ usbguard generate policey -X > /etc/usbguard/rules.conf —> allow all that are attached now on this system, block everything else - $ lsusb —> see all USBs that are connected - $ dmesg | grep -i authorized —> see logs - $ usbguard allow-device [id in $lsusb] —> runtime - $ usbguard allow-device [id in $lsusb] -p —> permanent - $ vim /etc/usbguard/rules.conf —> see all rules - $ usbguard list-rules - $ usbguard remove-rule 8 (number of rule in list-rules) **Reset Root Password & hardening GRUB2:** - reboot - press e on menu that choose OSs - before initrd, at the end of linux kernel line, add : rd.break —> it is going to interupt system when loading - cntrl-x - system is mounted in read-only now - $ mount -o remount,rw sysroot - chroot /sysroot/ - sh-4.4$ passwd root —> set new pass - if now restart, password is not set. problem is selinux, because lables are changed and selinux is not gonna accept this new one we set. for bypassing it $ touch /.autorelabel , by doing this we are forcing selinux to re-lable all selinux lables after boot - $ exit - $ reboot - how to prevent this from happening : - $ grub2-setpassword —> will change /boot/grub2/user.cfg - $ grub2-mkconfig -o /boot/grub2/grub.cfg —> to save changes in user.cfg into grub **Securing cronjob:** - one of things that an attacker does is modifing cron job to automate a task or operate a code periodically - $ vim /etc/cron.allow —> define only user that can access this - root **FreeIPA:** - centralized authentication for user’s identity. ldap and kerbros and CA and lots of other things will be integreated - users created in FreeIP will not be accessible in et/shadow - $ yum install ipa-server ipa-server-dns —> ipa-server-dns for dns resolving. if ahd dns in network don’t install this - $ ipa-sever-install